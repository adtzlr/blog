<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://adtzlr.github.io/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://adtzlr.github.io/blog/" rel="alternate" type="text/html" /><updated>2020-09-21T13:42:05-05:00</updated><id>https://adtzlr.github.io/blog/feed.xml</id><title type="html">adtzlr</title><subtitle>Andreas Dutzler</subtitle><entry><title type="html">How to install a Fortran Compiler for MSC.Marc</title><link href="https://adtzlr.github.io/blog/markdown/2018/02/06/FortranMarc.html" rel="alternate" type="text/html" title="How to install a Fortran Compiler for MSC.Marc" /><published>2018-02-06T00:00:00-06:00</published><updated>2018-02-06T00:00:00-06:00</updated><id>https://adtzlr.github.io/blog/markdown/2018/02/06/FortranMarc</id><content type="html" xml:base="https://adtzlr.github.io/blog/markdown/2018/02/06/FortranMarc.html">&lt;h1 id=&quot;how-to-install-a-fortran-compiler-for-mscmarc&quot;&gt;How to install a Fortran Compiler for MSC.Marc&lt;/h1&gt;

&lt;p&gt;In this post I’ll discuss all the necessary steps to install the Intel Fortran compiler for MSC.Marc. At first we have to find out the necessary tools to compile fortran subroutines on Windows. In every Release Guide of MSC.Marc there is a table which versions of the Intel Compiler are compatible. Make sure to download this specific versions as even newer compiler versions may lead to problems. For MSC.Marc 2016 the Fortran Version is &lt;strong&gt;Intel XE2015&lt;/strong&gt; and &lt;strong&gt;Microsoft Visual Studio 2013&lt;/strong&gt;. Be sure to uninstall &lt;em&gt;all&lt;/em&gt; versions of MSC.Marc before continuing with the following steps.&lt;/p&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;
&lt;p&gt;It is important to install the software tools in the following order. In this way we avoid problems that software B is not finding the required software A inside the registry.&lt;/p&gt;

&lt;h3 id=&quot;visual-studio-20xx&quot;&gt;Visual Studio 20xx&lt;/h3&gt;
&lt;p&gt;We start with installing Microsft Visual Studio 20xx. Go to the &lt;a href=&quot;https://my.visualstudio.com/Downloads&quot;&gt;Visual Studio Download Page&lt;/a&gt; and search for &lt;em&gt;visual studio community 20xx&lt;/em&gt; (older versions are easier to find with the exact search string). Download the installer and choose the &lt;em&gt;Custom&lt;/em&gt; install option. As noted by &lt;a href=&quot;https://software.intel.com/en-us/articles/installing-visual-studio-2015-for-use-with-intel-compilers&quot;&gt;Intel&lt;/a&gt; it is necessary to install &lt;em&gt;Common Tools for Visual C++ 2015&lt;/em&gt; which is not activated by default. Restart your Computer.&lt;/p&gt;

&lt;h3 id=&quot;intel-xe20xx-composer&quot;&gt;Intel XE20xx Composer&lt;/h3&gt;
&lt;p&gt;After the installation of Visual Studio is completed we proceed with the Fortran compiler by Intel. Search for the Intel Download Page (or, if you’re student visit &lt;a href=&quot;https://software.intel.com/en-us/qualify-for-free-software/student&quot;&gt;this site&lt;/a&gt;) and download &lt;strong&gt;Intel Parallel Studio XE&lt;/strong&gt; for Windows. Once again: use exact the same version as noted inside the Document &lt;em&gt;MSC.Marc Release Guide&lt;/em&gt;. Restart your Computer again to make sure all environmental variables are updated in your system.&lt;/p&gt;

&lt;h3 id=&quot;mscmarc-mentat-20xx&quot;&gt;MSC.Marc Mentat 20xx&lt;/h3&gt;
&lt;p&gt;Now you may install MSC.Marc without any special considerations regarding Fortran compiling support. All necessary paths are set and detected automatically by Marc.&lt;/p&gt;</content><author><name></name></author><category term="markdown" /><summary type="html">How to install a Fortran Compiler for MSC.Marc</summary></entry><entry><title type="html">Initial Release of Tensor Toolbox for Fortran</title><link href="https://adtzlr.github.io/blog/markdown/2017/11/26/TensorToolbox.html" rel="alternate" type="text/html" title="Initial Release of Tensor Toolbox for Fortran" /><published>2017-11-26T00:00:00-06:00</published><updated>2017-11-26T00:00:00-06:00</updated><id>https://adtzlr.github.io/blog/markdown/2017/11/26/TensorToolbox</id><content type="html" xml:base="https://adtzlr.github.io/blog/markdown/2017/11/26/TensorToolbox.html">&lt;h1 id=&quot;introducing-tensor-toolbox-for-fortran&quot;&gt;Introducing Tensor Toolbox for Fortran&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/adtzlr/ttb&quot;&gt;Tensor Toolbox for Modern Fortran (ttb)&lt;/a&gt; is a Fortran module to add Tensor features to Fortran. It provides derived data types from general arrays for rank 2 and rank 4 tensors (and it’s symmetric variants). Computation of the deviatoric part, fourth-order identity tensor, dot product, double-dot product, etc. is available without constructing any loops by the user. For further information read the full post or have a look at the &lt;a href=&quot;https://github.com/adtzlr/ttb&quot;&gt;ttb-repository&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;a-short-overview&quot;&gt;A short overview&lt;/h2&gt;

&lt;p&gt;Commercial FEM software packages often offer interfaces (user subroutines written in Fortran) for custom defined user materials like UMAT in Abaqus or HYPELA2 in MSC.Marc. Unlike other scientific programming languages like MATLAB or Python Fortran is not as comfortable to use when dealing with high level programming features of tensor manipulation. On the other hand it’s super fast - so why not combine the handy features from MATLAB or Python’s NumPy/Scipy with the speed of Fortran? That’s the reason why I started working on a simple but effective module called &lt;strong&gt;Tensor Toolbox for Modern Fortran&lt;/strong&gt;. I adopted the idea to my needs from &lt;a href=&quot;http://nbn-resolving.de/urn:nbn:de:bsz:ch1-qucosa-222075&quot;&gt;Naumann, C. (2016)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It provides the following basic operations for tensor calculus (all written in double precision &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;real(kind=8)&lt;/code&gt;):&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Dot Product &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C(i,j) = A(i,k) B(k,j)&lt;/code&gt; written as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A*B&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A.dot.B&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Double Dot Product &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A(i,j) B(i,j)&lt;/code&gt; written as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A**B&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A.ddot.B&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Dyadic Product &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C(i,j,k,l) = A(i,j) B(k,l)&lt;/code&gt; written as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A.dya.B&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Addition / Subtraction &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C(i,j) = A(i,j) + B(i,j)&lt;/code&gt; written as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A+B&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A.add.B&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Multiplication and Divison by a Scalar &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C(i,j) = A(i,j) - B(i,j)&lt;/code&gt; written as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A-B&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A.sub.B&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Deviatoric Part of Tensor  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dev(C) = C - tr(C)/3 * Eye&lt;/code&gt; written as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dev(C)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Transpose and Permutation of indices &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B(i,j,k,l) = A(i,k,j,l)&lt;/code&gt; written as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B = permute(A,1,3,2,4)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Assigment of a real-valued Scalar to all components of a Tensor &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A = 0.0&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A = 0.d0&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Assigment of a real-valued Array to a Tensor with matching dimensions &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A = B&lt;/code&gt; where B is an Array and A a Tensor&lt;/li&gt;
  &lt;li&gt;Rank 2 Identity tensor of input type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Eye = identity2(Eye)&lt;/code&gt; with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = Eye*C&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Rank 4 Identity tensor (symmetric variant) of input type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I4 = identity4(Eye)&lt;/code&gt; with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = I4(Eye)**C&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inv(C) = identitiy4(inv(C))**C&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;basic-usage&quot;&gt;Basic Usage&lt;/h2&gt;
&lt;p&gt;The most basic example on how to use this module is to &lt;a href=&quot;https://github.com/adtzlr/ttb/archive/master.zip&quot;&gt;download the module&lt;/a&gt;, put the ‘ttb’-Folder in your working directory and add two lines of code:&lt;/p&gt;

&lt;div class=&quot;language-fortran highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'ttb/ttb_library.f'&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;script101_ttb&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Tensor&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;! user code&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;script101_ttb&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;include 'ttb/ttb_library.f'&lt;/code&gt; statement replaces the line with the content of the ttb-module. The first line in a program or subroutine is now a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;use Tensor&lt;/code&gt; statement. That’s it - now you’re ready to go.&lt;/p&gt;

&lt;h2 id=&quot;neo-hookean-material&quot;&gt;Neo-Hookean Material&lt;/h2&gt;
&lt;p&gt;With the help of the Tensor module the Second Piola-Kirchhoff stress tensor &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S&lt;/code&gt; of a nearly-incompressible Neo-Hookean material model is basically a one-liner:&lt;/p&gt;

&lt;div class=&quot;language-fortran highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;det&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;-2.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Eye&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;det&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;sources&quot;&gt;Sources&lt;/h2&gt;
&lt;p&gt;Naumann, C.: &lt;a href=&quot;http://nbn-resolving.de/urn:nbn:de:bsz:ch1-qucosa-222075&quot;&gt;Chemisch-mechanisch gekoppelte Modellierung und Simulation oxidativer Alterungsvorgänge in Gummibauteilen (German)&lt;/a&gt;. PhD thesis. Fakultät für Maschinenbau der Technischen Universität Chemnitz, 2016.&lt;/p&gt;</content><author><name></name></author><category term="markdown" /><summary type="html">Introducing Tensor Toolbox for Fortran</summary></entry></feed>