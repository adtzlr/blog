<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://adtzlr.github.io/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://adtzlr.github.io/blog/" rel="alternate" type="text/html" /><updated>2020-09-23T06:03:04-05:00</updated><id>https://adtzlr.github.io/blog/feed.xml</id><title type="html">adtzlr</title><subtitle>Andreas Dutzler</subtitle><entry><title type="html">Geometrisch exakte eindimensionale (1d) Finite-Elemente-Methode Teil I - Kinematik, Kinetik und Konstitution</title><link href="https://adtzlr.github.io/blog/markdown/2020/09/21/StabNichtlinearA.html" rel="alternate" type="text/html" title="Geometrisch exakte eindimensionale (1d) Finite-Elemente-Methode Teil I - Kinematik, Kinetik und Konstitution" /><published>2020-09-21T00:00:00-05:00</published><updated>2020-09-21T00:00:00-05:00</updated><id>https://adtzlr.github.io/blog/markdown/2020/09/21/StabNichtlinearA</id><content type="html" xml:base="https://adtzlr.github.io/blog/markdown/2020/09/21/StabNichtlinearA.html">&lt;h1 id=&quot;einleitung&quot;&gt;Einleitung&lt;/h1&gt;

&lt;p&gt;In dieser Beitragsserie werden wir die Grundlagen der geometrisch exakten eindimensionalen Finite-Elemente-Methode mit beliebiger elastischer Materialnichtlinearität zur Berechnung statischer, strukturmechanischer Aufgabenstellungen erarbeiten. Im Zuge dessen werden wir versuchen, eine lineare Verkoppelung der Normalkraft mit einem generalisierten Verzerrungsmaß für ein hyperelastisches Material einzubauen. Das ist dann doch nicht ganz so trivial, wie man zunächst meinen möchte. Manche Dinge sind außerdem nicht direkt vom eindimensionalen Stab auf ein Stabelement im dreidimensionalen Raum übertragbar, darauf wird im Beitrag an den nötigen Stellen immer wieder eingegangen. Und die Beitragsreihe soll vor allem eines zeigen: Erklärt man die Dinge der Reihe nach, dann ist die Thematik ohne großes Vorwissen für Interessierte recht einfach verständlich.&lt;/p&gt;

&lt;h1 id=&quot;kinematik-eines-stabelements&quot;&gt;Kinematik eines Stabelements&lt;/h1&gt;

&lt;p&gt;In der undeformierten Konfiguration eines Festkörpers - also eines Stabes - wird das differentielle Stabelement an der Position $X$ und mit der Länge $dX$ identifiziert.&lt;/p&gt;

&lt;p&gt;Die Deformation wird durch eine eins-zu-eins Abbildung der Punktkoordinaten der undeformierten Konfiguration in die deformierte Konfiguration beschrieben.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/DeformationStab.png&quot; alt=&quot;&quot; title=&quot;Deformation eines differentiellen Stabelements&quot; /&gt;&lt;/p&gt;

&lt;p&gt;$x = \chi(X)$&lt;/p&gt;

&lt;p&gt;Dies führt auf die Koordinate der deformierten Konfiguration. Der eindimensionale Deformationsgradient mit Bezug auf die unverformte Konfiguration beinhaltet die differentielle Längenänderung in einem Bereich rund um einen in der undeformierten Konfiguration identifizierten Punkt $X$.&lt;/p&gt;

&lt;p&gt;$F=\frac{d\chi(X)}{dX} = \frac{dx}{dX}$&lt;/p&gt;

&lt;p&gt;$dx = F dX$&lt;/p&gt;

&lt;p&gt;Das deformierte Positionsfeld wird durch Addition eines Verschiebungsfeldes zum undeformierten Positionsfeld bestimmt. Daraus ergibt sich der Zusammenhang, dass der Deformationsgradient gleich dem Verschiebungsgradient plus eins ist.&lt;/p&gt;

&lt;p&gt;$F=\frac{d(X+U)}{dX}=1+\frac{dU}{dX}$&lt;/p&gt;

&lt;p&gt;Das Verhältnis aus deformierter zu undeformierter Länge des differentiellen Stabelements bezeichnen wir als Streckung $\lambda$, unabhängig davon ob eine Längenzu- oder abnahme vorliegt. Mit anderen Worten: Wir sparen uns also den Begriff der &lt;em&gt;Stauchung&lt;/em&gt; und bringen diese in einer Art generalisierter Streckung unter.&lt;/p&gt;

&lt;p&gt;$\lambda=\frac{dx}{dX}=\frac{dl}{dL}$&lt;/p&gt;

&lt;p&gt;Damit ist die Deformation eines differentiellen Stabelements eindeutig charakterisiert.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hinweis&lt;/strong&gt;: Die direkte Berechnung der Streckung entlang eines im Raum liegenden Stabes ist auf diese Art nicht möglich! Hier muss über das Skalarprodukt $dl^2 = d\boldsymbol{x}^T d\boldsymbol{x}$ die quadratische Streckung berechnet werden (Satz von Pythagoras). Danach wird durch Ziehen der Wurzel die Stabstreckung ermittelt. Die Wurzel darf man aber nur &lt;em&gt;entlang des Stabes&lt;/em&gt; ziehen, wenn man das so sagen will. Die Skalarprodukte der Stabvektoren sind die einzige Möglichkeit, um im Raum überhaupt eine Längenmessung etablieren zu können. Dafür ist auch kein Wurzelziehen nötig.&lt;/p&gt;

&lt;h1 id=&quot;verzerrung&quot;&gt;Verzerrung&lt;/h1&gt;

&lt;p&gt;Die Verzerrung ist eine (nichtlineare) Funktion der Deformation, die im eindimensionalen Sinne monoton steigend im Sinne der Streckung sein soll. Für den Grenzfall unendlich großer und kleiner Streckungen soll sie idealerweise gegen $\pm \infty$ gehen.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;An dieser Steller fragt man sich vielleicht&lt;/strong&gt;: Warum &lt;em&gt;soll&lt;/em&gt; und nicht &lt;em&gt;muss&lt;/em&gt;? Nun, &lt;em&gt;unser&lt;/em&gt; Ziel einer strukturmechanischen Berechnung ist es ja, ein physikalisch stabiles Materialverhalten abzubilden. Aber was heißt denn konkret &lt;em&gt;physikalisch stabil&lt;/em&gt;? Darunter versteht man eine monoton steigende Normalkraft bei zunehmender Streckung. Erfüllt nun bereits die Verzerrung bis hin zu den Limits unendlicher Streckung diese Anforderungen, so hat man bereits eine gute Basis für die konstitutive Materialmodellierung. Aber keine Garantie - dazu später mehr.&lt;/p&gt;

&lt;p&gt;Um den undeformierten Zustand soll zudem die Steigung eins gelten, um im Falle infinitesimaler Streckungen die Ingenieurverzerrungen zu erhalten.&lt;/p&gt;

&lt;p&gt;Seth und Hill haben für eine generalisierte Verzerrung folgenden Vorschlag gemacht:&lt;/p&gt;

&lt;p&gt;$e^{(k)} = \frac{1}{k} (\lambda^k-1)$&lt;/p&gt;

&lt;p&gt;Wenn wir im weiteren Verlauf den Begriff Verzerrung verwenden, meinen wir immer diese generalisierten Verzerrungen. Erwähnenswert ist noch, dass für den Sonderfall $k=0$ die Seth-Hill-Verzerrungen auf die log. Verzerrung führt:&lt;/p&gt;

&lt;p&gt;$e^{(0)} = ln(\lambda)$&lt;/p&gt;

&lt;p&gt;Die Änderung der Verzerrung im Sinne der Streckung, mit anderen Worten die erste Variation der Verzerrung, berechnet sich zu:&lt;/p&gt;

&lt;p&gt;$\delta e^{(k)} = \frac{\lambda^k}{\lambda}~\delta \lambda$ .&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hinweis&lt;/strong&gt;: Auch hier gilt wieder: Die Streckung muss für Stäbe im dreidimensionalen Raum zunächst aus der Wurzel des Streckungsquadrats berechnet werden. Erst dann darf in Stabrichtung die (k)-Modifikation erfolgen. Einzig für den Sonderfall $k=2$ ist kein Wurzelziehen nötig, da die quadratische Länge des differentiellen Stabelements direkt aus dem Inprodukt der Stabvektoren resultiert.&lt;/p&gt;

&lt;h1 id=&quot;kinetik-kräftegleichgewicht-am-deformierten-system&quot;&gt;Kinetik (Kräftegleichgewicht am deformierten System)&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/GleichgewichtStab.png&quot; alt=&quot;&quot; title=&quot;Gleichgewicht am deformierten differentiellen Stabelement&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Wir betrachten ein differentielles Stabelement eines eindimensionalen Festkörpers (eines Stabs) in seiner deformierten Konfiguration und schneiden dieses frei. Im allgemeinen Belastungsfall treten am negativen und positiven Schnittufer voneinander verschiedene Normalkräfte auf. Die Normalkraft am negativen Schnittufer stellt den konstanten Grundanteil der Normalkraft dar und das positive Schnittufer beinhaltet zusätzlich differentielle Normalkraftänderungen entlang der deformierten Längskoordinate. Desweiteren wird eine Volumslast entlang der Längskoordinate mit vorerst beliebiger Abhängigkeit zur Längskoordinate angenommen. Das Kräftegleichgewicht am freigeschnittenen differentiellen Linienlement lautet:&lt;/p&gt;

&lt;p&gt;$\sum N = 0 = -\sigma(x)~a(x) + \sigma(x)~a(x) + \frac{d\sigma(x)}{dx}~a(x) + b(x)~a(x)$&lt;/p&gt;

&lt;p&gt;Nach Division durch die deformierte Querschnittsfläche bleibt&lt;/p&gt;

&lt;p&gt;$\frac{d\sigma}{dx} + b = 0$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hinweis:&lt;/strong&gt; Das differentielle Kräftegleichgewicht wird im Mehrdimensionalen zur Vektorgleichung $\boldsymbol{div}(\boldsymbol{\sigma})+\boldsymbol{b} = \boldsymbol{0}$.&lt;/p&gt;

&lt;h1 id=&quot;konstitution&quot;&gt;Konstitution&lt;/h1&gt;

&lt;p&gt;Im letzten Schritt müssen wir noch eine Verbindung zwischen der Verzerrung und dem Kräftegleichgewicht herstellen, indem wir das Materialverhalten miteinbeziehen: Wir verheiraten die Verzerrung mit der Normalkraft über das konstitutive Materialgesetz, dem Ehevertrag wenn man so will. Wir fordern außerdem, dass dieses Materialgesetz im Sinne eines Potentials als Verzerrungsenergiefunktion vorliegen soll, was uns zum Begriff der Hyperelastizität führt.&lt;/p&gt;

&lt;h3 id=&quot;hyperelastizität&quot;&gt;Hyperelastizität&lt;/h3&gt;

&lt;p&gt;Hyperelastizität bedeutet, dass eine Verzerrungsenergiefunktion je Einheit Masse existiert. Diese Verzerrungsenergiefunktion charakterisiert das Materialverhalten im Sinne der Deformation. Warum bezieht man sie je Einheit Masse? Weil die Masse die einzige Konstante eines Festkörpers während der Deformation darstellt.&lt;/p&gt;

&lt;p&gt;Masse? Wir sind eindimensional unterwegs, wie soll das klappen? Da ein eindimensionaler Stab nur durch eine Querschnittsfläche und einer Dichte eine Masse bekommt, muss die eindimensionale Betrachtungsweise an dieser Stelle zwangsläufig um eine Querschnittsfläche erweitert werden!&lt;/p&gt;

&lt;p&gt;Das differentielle Potential der inneren Kräfte ist folglich das Produkt aus Verzerrungsenergiefunktion je Einheit Masse und differentieller Masse. Um die Potentialbeiträge der externen Kräfte kümmern wir uns derzeit nicht.&lt;/p&gt;

&lt;p&gt;$d\Pi_{int} = \psi_m(e^{(k)})~dm$&lt;/p&gt;

&lt;p&gt;Wie bereits erwähnt: Die Masse eines differentiellen Stabelements ist in einem geschlossenen System über den gesamten Deformationsvorgang hinweg konstant.&lt;/p&gt;

&lt;p&gt;$dm = \rho~a~dx = \rho_0~A~dX$&lt;/p&gt;

&lt;h2 id=&quot;verzerrungsenergiefunktion-je-einheit-unverformtes-volumen&quot;&gt;Verzerrungsenergiefunktion je Einheit unverformtes Volumen&lt;/h2&gt;

&lt;p&gt;Multipliziert man die Dichte der unverformten Konfiguration mit der Verzerrungsenergiefunktion je Einheit Masse, so führt das auf die Verzerrungsenergiefunktion je Einheit unverformtes Volumen. Für ein differentielles Stabelement ist das differentielle Volumen durch das Produkt aus unverformter Querschnittsfläche und differentieller Länge gegeben.&lt;/p&gt;

&lt;p&gt;$d\Pi_{int} = \psi(e^{(k)})~A~dX$&lt;/p&gt;

&lt;p&gt;Die Variation dieser Verzerrungsenergiefunktion nach der Deformation führt auf arbeitskonjugierte Paare aus Spannung und inkrementeller Verzerrung. Die Ableitung der Verzerrungsenergiefunktion nach der Verzerrung wird als Spannung identifiziert, weil das Paar einen inkrementellen Arbeitsausdruck der inneren Kräfte ergibt.&lt;/p&gt;

&lt;p&gt;$\delta d\Pi_{int} = \delta\psi(e^{(k)})~A~dX$&lt;/p&gt;

&lt;p&gt;$\delta d\Pi_{int} = \frac{d\psi(e^{(k)})}{de^{(k)}} \delta e^{(k)} ~A~dX$&lt;/p&gt;

&lt;p&gt;Daraus erhält man die zur inkrementellen Verzerrungsgröße $\delta e^{(k)}$ zugehörige Spannung&lt;/p&gt;

&lt;p&gt;$s^{(k)}=\frac{d\psi(e^{(k)})}{de^{(k)}}$&lt;/p&gt;

&lt;h2 id=&quot;lineare-spannungs-verzerrungs-relation&quot;&gt;Lineare Spannungs-Verzerrungs-Relation&lt;/h2&gt;

&lt;p&gt;Um eine lineare Spannungs-Verzerrungs-Verkoppelung zu erhalten, muss die Verzerrungsenergiefunktion eine quadratische Funktion der Verzerrung sein. Der E-Modul dient hierbei als Materialparameter.&lt;/p&gt;

&lt;p&gt;$\psi(e^{(k)}) = \frac{E}{2}~{e^{(k)}}^2$&lt;/p&gt;

&lt;p&gt;$s^{(k)}=E~e^{(k)}$&lt;/p&gt;

&lt;h1 id=&quot;wie-kommt-man-mit-all-dem-wissen-schlussendlich-zur-stab-normalkraft&quot;&gt;Wie kommt man mit all dem Wissen schlussendlich zur Stab-Normalkraft?&lt;/h1&gt;

&lt;p&gt;Soweit, so gut. Wir haben eine fiktive (k)-Spannung berechnet. Wie schaffen wir es jetzt, einen Zusammenhang zur Normalkraft herzustellen? Alles der Reihe nach. Die Normalkraft ist für ein differentielles Stabelement als Produkt aus Cauchy-Spannung und deformierter Querschnittsfläche gegeben (auch bekannt als Cauchysches Fundamentaltheorem).&lt;/p&gt;

&lt;p&gt;$N = \sigma~a$&lt;/p&gt;

&lt;p&gt;Durch partielle Integration des differentiellen Kräftegleichgewichts (wird eventuell in einem weiteren Beitrag genauer erläutert…) erhält man, dass die virtuelle Arbeit der inneren Kräfte je Einheit deformiertes Volumen als Produkt von Cauchy-Spannung und räumlichen Verschiebungsgradienten definiert ist. Das negative Vorzeichen kommt durch die partielle Integration zustande: Die Summe aller Randterme minus der Änderung im Inneren ist gleich Null. Diese Änderung im Inneren ist, naja, etwas salopp gesagt, die virtuelle Arbeit der inneren Kräfte.&lt;/p&gt;

&lt;p&gt;$\delta dW_{int} = - \sigma~\frac{d\delta U}{dx}~dv$&lt;/p&gt;

&lt;p&gt;$\delta dW_{int} = - \sigma~\delta\lambda \lambda^{-1}~a~dx$&lt;/p&gt;

&lt;p&gt;Durch einen Vergleich&lt;/p&gt;

&lt;p&gt;$s^{(k)}\lambda^k \delta\lambda\lambda^{-1}~A~dX = \sigma~\delta\lambda \lambda^{-1}~a~dx$&lt;/p&gt;

&lt;p&gt;erhält man die Cauchy-Spannung in Abhängigkeit der Verzerrungsenergiefunktion&lt;/p&gt;

&lt;p&gt;$\sigma = \frac{1}{J} s^{(k)}\lambda^k$.&lt;/p&gt;

&lt;h2 id=&quot;normalkraft-als-funktion-der-verzerrung&quot;&gt;Normalkraft als Funktion der Verzerrung&lt;/h2&gt;

&lt;p&gt;…und in weiterer Folge der Streckung:&lt;/p&gt;

&lt;p&gt;$N = s^{(k)}\lambda^{k-1} A$&lt;/p&gt;

&lt;p&gt;$N = EA~e^{(k)}\lambda^{k-1}$&lt;/p&gt;

&lt;p&gt;Man sieht also, dass die Normalkraft trotz aller Bemühungen &lt;strong&gt;nicht&lt;/strong&gt;-linear mit der Verzerrung interagiert! Die Umrechnung des Verzerrungsinkrements auf das Inkrement der Streckung macht uns hier einen Strich durch die Rechnung. Das ist im Grunde aber nicht weiter schlimm, es ist eben so.&lt;/p&gt;

&lt;p&gt;Da wir jetzt hinsichtlich der Kinematik, der Kinetik und der Konstitution alle Vorbereitungen getroffen haben, geht es im nächsten Beitrag weiter mit der Diskretisierung. Aber zuvor noch ein letztes Gedankenspiel: Wie müsste eine Verzerrungsenergiefunktion aussehen, die eine lineare Verkoppelung der Normalkraft mit der Verzerrung ermöglicht?&lt;/p&gt;

&lt;h2 id=&quot;normalkraft-als-lineare-funktion-der-verzerrung&quot;&gt;Normalkraft als lineare Funktion der Verzerrung&lt;/h2&gt;

&lt;p&gt;Bei dieser Fragestellung gehen wir nicht vom Formelbau einer gegebenen Verzerrungsenergiefunktion aus, sondern von der gewünschten Formelarchitektur der Normalkraft:&lt;/p&gt;

&lt;p&gt;$N = \frac{d\psi}{d\lambda} A = EA~e^{(k)}$.&lt;/p&gt;

&lt;p&gt;Damit können wir die Verzerrungsfunktion durch einmaliges Integrieren nach der Streckung erzeugen. Die Integrationskonstante bestimmen wir im Anschluss mit der Forderung, dass im undeformierten Zustand keine Verzerrungsenergie auftreten soll.&lt;/p&gt;

&lt;p&gt;$\psi = \int \frac{d\psi}{d\lambda} d\lambda = \int \frac{E}{k}(\lambda^k-1)~d\lambda$&lt;/p&gt;

&lt;p&gt;Versucht man obige Gleichung zu integrieren, so erhält man eine Verzerrungsenergiefunktion, die nicht für alle beliebigen (k)-Exponenten konvex ist. Eine strikt konvexe Verzerrungsenergiefunktion erhalten wir nur dann, wenn wir zunächst den Sonderfall der log. Verzerrungen (k=0) annehmen, dann integrieren und erst zum Schluss die log. Verzerrung durch die allgemeine (k)-Verzerrung ersetzen. Schlussendlich muss man noch einen auftretenden Vorfaktor eliminieren und wir erhalten die Verzerrungsenergiefunktion, die eine lineare Verkoppelung der Normalkraft mit der Verzerrung erzeugt:&lt;/p&gt;

&lt;p&gt;$\psi = \frac{E}{1+k}[\lambda (e^{(k)}-1)] + \psi_0$ 	mit 	$\psi_0 = \frac{1}{1+k}$.&lt;/p&gt;

&lt;p&gt;Als Fleißaufgabe kann man jetzt wieder die fiktive (k)-Spannung berechnen. Hierzu muss man in der Verzerrungsenergiefunktion die Streckung durch die Verzerrung ausdrücken und einmal nach der Verzerrung ableiten.&lt;/p&gt;

&lt;p&gt;$\lambda = (1+k~e^{(k)})^{1/k}$&lt;/p&gt;

&lt;p&gt;$s^{(k)} = \frac{d\psi}{de^{(k)}} = \frac{E}{1+k}\left[\frac{\lambda}{\lambda^k} (e^{(k)}-1)+\lambda\right]$&lt;/p&gt;

&lt;h2 id=&quot;beispiel-k0&quot;&gt;Beispiel k=0&lt;/h2&gt;
&lt;p&gt;Nachfolgend sind die Verzerrungsenergiefunktion, (k)-Spannung und Normalkraft für k=0 in Abhängigkeit der Streckung dargestellt.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/NormalkraftStabk0.png&quot; alt=&quot;&quot; title=&quot;Verläufe für k=0&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="markdown" /><summary type="html">Einleitung</summary></entry><entry><title type="html">How to install a Fortran Compiler for MSC.Marc</title><link href="https://adtzlr.github.io/blog/markdown/2018/02/06/FortranMarc.html" rel="alternate" type="text/html" title="How to install a Fortran Compiler for MSC.Marc" /><published>2018-02-06T00:00:00-06:00</published><updated>2018-02-06T00:00:00-06:00</updated><id>https://adtzlr.github.io/blog/markdown/2018/02/06/FortranMarc</id><content type="html" xml:base="https://adtzlr.github.io/blog/markdown/2018/02/06/FortranMarc.html">&lt;h1 id=&quot;how-to-install-a-fortran-compiler-for-mscmarc&quot;&gt;How to install a Fortran Compiler for MSC.Marc&lt;/h1&gt;

&lt;p&gt;In this post I’ll discuss all the necessary steps to install the Intel Fortran compiler for MSC.Marc. At first we have to find out the necessary tools to compile fortran subroutines on Windows. In every Release Guide of MSC.Marc there is a table which versions of the Intel Compiler are compatible. Make sure to download this specific versions as even newer compiler versions may lead to problems. For MSC.Marc 2016 the Fortran Version is &lt;strong&gt;Intel XE2015&lt;/strong&gt; and &lt;strong&gt;Microsoft Visual Studio 2013&lt;/strong&gt;. Be sure to uninstall &lt;em&gt;all&lt;/em&gt; versions of MSC.Marc before continuing with the following steps.&lt;/p&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;
&lt;p&gt;It is important to install the software tools in the following order. In this way we avoid problems that software B is not finding the required software A inside the registry.&lt;/p&gt;

&lt;h3 id=&quot;visual-studio-20xx&quot;&gt;Visual Studio 20xx&lt;/h3&gt;
&lt;p&gt;We start with installing Microsft Visual Studio 20xx. Go to the &lt;a href=&quot;https://my.visualstudio.com/Downloads&quot;&gt;Visual Studio Download Page&lt;/a&gt; and search for &lt;em&gt;visual studio community 20xx&lt;/em&gt; (older versions are easier to find with the exact search string). Download the installer and choose the &lt;em&gt;Custom&lt;/em&gt; install option. As noted by &lt;a href=&quot;https://software.intel.com/en-us/articles/installing-visual-studio-2015-for-use-with-intel-compilers&quot;&gt;Intel&lt;/a&gt; it is necessary to install &lt;em&gt;Common Tools for Visual C++ 2015&lt;/em&gt; which is not activated by default. Restart your Computer.&lt;/p&gt;

&lt;h3 id=&quot;intel-xe20xx-composer&quot;&gt;Intel XE20xx Composer&lt;/h3&gt;
&lt;p&gt;After the installation of Visual Studio is completed we proceed with the Fortran compiler by Intel. Search for the Intel Download Page (or, if you’re student visit &lt;a href=&quot;https://software.intel.com/en-us/qualify-for-free-software/student&quot;&gt;this site&lt;/a&gt;) and download &lt;strong&gt;Intel Parallel Studio XE&lt;/strong&gt; for Windows. Once again: use exact the same version as noted inside the Document &lt;em&gt;MSC.Marc Release Guide&lt;/em&gt;. Restart your Computer again to make sure all environmental variables are updated in your system.&lt;/p&gt;

&lt;h3 id=&quot;mscmarc-mentat-20xx&quot;&gt;MSC.Marc Mentat 20xx&lt;/h3&gt;
&lt;p&gt;Now you may install MSC.Marc without any special considerations regarding Fortran compiling support. All necessary paths are set and detected automatically by Marc.&lt;/p&gt;</content><author><name></name></author><category term="markdown" /><summary type="html">How to install a Fortran Compiler for MSC.Marc</summary></entry><entry><title type="html">Initial Release of Tensor Toolbox for Fortran</title><link href="https://adtzlr.github.io/blog/markdown/2017/11/26/TensorToolbox.html" rel="alternate" type="text/html" title="Initial Release of Tensor Toolbox for Fortran" /><published>2017-11-26T00:00:00-06:00</published><updated>2017-11-26T00:00:00-06:00</updated><id>https://adtzlr.github.io/blog/markdown/2017/11/26/TensorToolbox</id><content type="html" xml:base="https://adtzlr.github.io/blog/markdown/2017/11/26/TensorToolbox.html">&lt;h1 id=&quot;introducing-tensor-toolbox-for-fortran&quot;&gt;Introducing Tensor Toolbox for Fortran&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/adtzlr/ttb&quot;&gt;Tensor Toolbox for Modern Fortran (ttb)&lt;/a&gt; is a Fortran module to add Tensor features to Fortran. It provides derived data types from general arrays for rank 2 and rank 4 tensors (and it’s symmetric variants). Computation of the deviatoric part, fourth-order identity tensor, dot product, double-dot product, etc. is available without constructing any loops by the user. For further information read the full post or have a look at the &lt;a href=&quot;https://github.com/adtzlr/ttb&quot;&gt;ttb-repository&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;a-short-overview&quot;&gt;A short overview&lt;/h2&gt;

&lt;p&gt;Commercial FEM software packages often offer interfaces (user subroutines written in Fortran) for custom defined user materials like UMAT in Abaqus or HYPELA2 in MSC.Marc. Unlike other scientific programming languages like MATLAB or Python Fortran is not as comfortable to use when dealing with high level programming features of tensor manipulation. On the other hand it’s super fast - so why not combine the handy features from MATLAB or Python’s NumPy/Scipy with the speed of Fortran? That’s the reason why I started working on a simple but effective module called &lt;strong&gt;Tensor Toolbox for Modern Fortran&lt;/strong&gt;. I adopted the idea to my needs from &lt;a href=&quot;http://nbn-resolving.de/urn:nbn:de:bsz:ch1-qucosa-222075&quot;&gt;Naumann, C. (2016)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It provides the following basic operations for tensor calculus (all written in double precision &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;real(kind=8)&lt;/code&gt;):&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Dot Product &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C(i,j) = A(i,k) B(k,j)&lt;/code&gt; written as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A*B&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A.dot.B&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Double Dot Product &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A(i,j) B(i,j)&lt;/code&gt; written as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A**B&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A.ddot.B&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Dyadic Product &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C(i,j,k,l) = A(i,j) B(k,l)&lt;/code&gt; written as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A.dya.B&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Addition / Subtraction &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C(i,j) = A(i,j) + B(i,j)&lt;/code&gt; written as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A+B&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A.add.B&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Multiplication and Divison by a Scalar &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C(i,j) = A(i,j) - B(i,j)&lt;/code&gt; written as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A-B&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = A.sub.B&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Deviatoric Part of Tensor  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dev(C) = C - tr(C)/3 * Eye&lt;/code&gt; written as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dev(C)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Transpose and Permutation of indices &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B(i,j,k,l) = A(i,k,j,l)&lt;/code&gt; written as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B = permute(A,1,3,2,4)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Assigment of a real-valued Scalar to all components of a Tensor &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A = 0.0&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A = 0.d0&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Assigment of a real-valued Array to a Tensor with matching dimensions &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A = B&lt;/code&gt; where B is an Array and A a Tensor&lt;/li&gt;
  &lt;li&gt;Rank 2 Identity tensor of input type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Eye = identity2(Eye)&lt;/code&gt; with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = Eye*C&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Rank 4 Identity tensor (symmetric variant) of input type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I4 = identity4(Eye)&lt;/code&gt; with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C = I4(Eye)**C&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inv(C) = identitiy4(inv(C))**C&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;basic-usage&quot;&gt;Basic Usage&lt;/h2&gt;
&lt;p&gt;The most basic example on how to use this module is to &lt;a href=&quot;https://github.com/adtzlr/ttb/archive/master.zip&quot;&gt;download the module&lt;/a&gt;, put the ‘ttb’-Folder in your working directory and add two lines of code:&lt;/p&gt;

&lt;div class=&quot;language-fortran highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'ttb/ttb_library.f'&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;script101_ttb&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Tensor&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;! user code&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;script101_ttb&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;include 'ttb/ttb_library.f'&lt;/code&gt; statement replaces the line with the content of the ttb-module. The first line in a program or subroutine is now a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;use Tensor&lt;/code&gt; statement. That’s it - now you’re ready to go.&lt;/p&gt;

&lt;h2 id=&quot;neo-hookean-material&quot;&gt;Neo-Hookean Material&lt;/h2&gt;
&lt;p&gt;With the help of the Tensor module the Second Piola-Kirchhoff stress tensor &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S&lt;/code&gt; of a nearly-incompressible Neo-Hookean material model is basically a one-liner:&lt;/p&gt;

&lt;div class=&quot;language-fortran highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;det&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;-2.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Eye&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;det&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;sources&quot;&gt;Sources&lt;/h2&gt;
&lt;p&gt;Naumann, C.: &lt;a href=&quot;http://nbn-resolving.de/urn:nbn:de:bsz:ch1-qucosa-222075&quot;&gt;Chemisch-mechanisch gekoppelte Modellierung und Simulation oxidativer Alterungsvorgänge in Gummibauteilen (German)&lt;/a&gt;. PhD thesis. Fakultät für Maschinenbau der Technischen Universität Chemnitz, 2016.&lt;/p&gt;</content><author><name></name></author><category term="markdown" /><summary type="html">Introducing Tensor Toolbox for Fortran</summary></entry></feed>